//
//  LevelAndPFSettingViewController.swift
//  OrrRock
//
//  Created by Ïù¥ÏÑ±ÎÖ∏, Yeni Hwang on 2022/10/21.
//

import UIKit

import AVFoundation
import AVKit
import SnapKit
import Photos

final class LevelAndPFSettingViewController: UIViewController {
    
    var videoInfoArray: [VideoInfo] = []
    
    private var cards: [SwipeableCardVideoView?] = []
    private var counter: Int = 0
    private var deleteConter: Int = 0
    private var currentSelectedLevel = -1
    private var selectedCard: Int = 0
    private var classifiedCard: Int = 0
    private var timeObserverToken: Any?
    private var firstCardtimeObserverToken: Any?
    
    private lazy var headerView: UIView = {
        let view = UIView()
        view.layer.zPosition = -1
        
        return view
    }()
    
    private lazy var titleLabel: UILabel = {
        let label = UILabel()
        label.text = "Ïä§ÏôÄÏù¥ÌîÑÎ•º ÌÜµÌï¥ ÎπÑÎîîÏò§Î•º Î∂ÑÎ•òÌï¥Ï£ºÏÑ∏Ïöî."
        label.textColor = .orrBlack
        label.font = .systemFont(ofSize: 17.0, weight: .semibold)
        
        return label
    }()
    
    private lazy var levelLabel: UILabel = {
        let label = UILabel()
        label.text = "Î†àÎ≤®"
        label.textColor = .orrBlack
        label.font = .systemFont(ofSize: 17.0, weight: .semibold)
        
        return label
    }()
    
    private lazy var levelButton: UIButton = {
        let button = UIButton()
        button.setTitle("ÏÑ†ÌÉùÏïàÌï®", for: .normal)
        button.setTitleColor(.black, for: .normal)
        button.titleLabel?.font = .systemFont(ofSize: 17.0, weight: .semibold)
        button.addTarget(self, action: #selector(pickLevel), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var levelButtonImage: UIImageView = {
        let imageView = UIImageView()
        imageView.image = UIImage(systemName: "chevron.down")
        imageView.tintColor = .orrGray500
        
        return imageView
    }()
    
    private lazy var levelStackView: UIStackView = {
        let stackView = UIStackView()
        stackView.axis = .horizontal
        stackView.alignment = .fill
        stackView.distribution = .equalSpacing
        stackView.spacing = 10
        
        return stackView
    }()
    
    private lazy var buttonStackView: UIStackView = {
        let stackView = UIStackView()
        stackView.axis = .horizontal
        stackView.alignment = .fill
        stackView.distribution = .equalSpacing
        stackView.spacing = 3
        
        return stackView
    }()
    
    private lazy var separator: UIView = {
        let separator = UIView()
        separator.backgroundColor = .orrBlack
        
        return separator
    }()
    
    private lazy var backgroundCardStackView: EmptyBackgroundView = {
        let view = EmptyBackgroundView()
        view.layer.zPosition = -1
        return view
    }()
    
    private lazy var emptyVideoView: UIView = {
        let view = UIView()
        view.backgroundColor = .orrGray300
        view.layer.cornerRadius = 10
        view.clipsToBounds = true
        
        return view
    }()
    
    private lazy var emptyVideoInformation: UILabel = {
        let label = UILabel()
        label.text = "Î™®Îì† ÎπÑÎîîÏò§Î•º Î∂ÑÎ•òÌñàÏäµÎãàÎã§!"
        label.textColor = .orrGray500
        label.font = .systemFont(ofSize: 15.0, weight: .regular)
        
        return label
    }()
    
    private lazy var failButton: CustomButton = {
        let button = CustomButton()
        button.setImage(UIImage(named: "fail_icon"), for: .normal)
        button.layer.cornerRadius = 37.0
        button.addTarget(self, action: #selector(didFailButton), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var deleteButton: CustomButton = {
        let button = CustomButton()
        button.setImage(UIImage(named: "delete"), for: .normal)
        button.layer.cornerRadius = 37.0
        button.addTarget(self, action: #selector(didDeleteButton), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var successButton: CustomButton = {
        let button = CustomButton()
        button.setImage(UIImage(named: "success_icon"), for: .normal)
        button.layer.cornerRadius = 37.0
        button.addTarget(self, action: #selector(didSuccessButton), for: .touchUpInside)
        
        return button
    }()
    
    private lazy var videoSlider: VideoSlider = {
        let slider = VideoSlider()
        slider.minimumTrackTintColor = .orrUPBlue
        slider.maximumTrackTintColor = .orrGray100
        slider.translatesAutoresizingMaskIntoConstraints = false
        slider.setThumbImage(UIImage(named: "sliderThumb"), for: .normal)
        slider.addTarget(self, action: #selector(didChangedSlider(_:)), for: .valueChanged)
        
        return slider
    }()
    
    private lazy var saveButton : UIButton = {
        let button = UIButton()
        button.setBackgroundColor(.orrUPBlue!, for: .normal)
        button.addTarget(self, action: #selector(tapSaveButton), for: .touchUpInside)
        button.setTitle("Ï†ÄÏû•ÌïòÍ∏∞", for: .normal)
        button.clipsToBounds = true
        button.layer.cornerRadius = 10.0
        button.setTitleColor(.white, for: .normal)
        button.isHidden = true
        
        return button
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        view.backgroundColor = .orrWhite
        
        navigationItem.leftBarButtonItem = CustomBackBarButtomItem(target: self, action: #selector(backButtonClicked))
        navigationItem.leftBarButtonItem?.tintColor = .orrUPBlue
        
        // card UI
        setUpLayout()
        
        createSwipeableCard() {
            self.cards.forEach { swipeCard in
                self.view.insertSubview(swipeCard!, at: 0)
                swipeCard!.snp.makeConstraints {
                    $0.top.equalTo(self.emptyVideoView.snp.top)
                    $0.bottom.equalTo(self.emptyVideoView.snp.bottom)
                    $0.leading.equalTo(self.emptyVideoView.snp.leading)
                    $0.trailing.equalTo(self.emptyVideoView.snp.trailing)
                }
                
                self.view.sendSubviewToBack(self.emptyVideoView)
                self.view.sendSubviewToBack(self.backgroundCardStackView)
                
                // gesture
                let gesture = UIPanGestureRecognizer()
                gesture.addTarget(self, action: #selector(self.handlerCard))
                swipeCard!.addGestureRecognizer(gesture)
            }
            CustomIndicator.stopLoading()
        }
    }
}

// Slider
private extension LevelAndPFSettingViewController {
    
    // ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÍ∞Ñ Î≥ÄÌôîÏóê Îî∞Î•∏ Ïä¨ÎùºÏù¥Îçî ÏóÖÎç∞Ïù¥Ìä∏
    func updateVideoSlider(card: SwipeableCardVideoView, time currentTime: CMTime) {
        if let currentItem = card.queuePlayer.currentItem {
            let duration = currentItem.duration
            if CMTIME_IS_INVALID(duration) { return }
            videoSlider.value = Float(CMTimeGetSeconds(currentTime) / CMTimeGetSeconds(duration))
        }
    }
    
    // Ïä¨ÎùºÏù¥Îçî ÌÑ∞ÏπòÏóê Îî∞Î•∏ ÎπÑÎîîÏò§ ÏóÖÎç∞Ïù¥Ìä∏
    @objc func didChangedSlider(_ sender: UISlider) {
        let card = cards[counter]?.queuePlayer
        
        guard let duration = card?.currentItem?.duration else { return }
        let value = Float64(sender.value) * CMTimeGetSeconds(duration)
        let seekTime = CMTime(value: CMTimeValue(value), timescale: 1)
        card?.currentItem?.seek(to: seekTime)
    }
    
    func addPeriodicTimeObserver(card: SwipeableCardVideoView, isFirstCard: Bool){
        
        let interval = CMTime(seconds: 0.0001, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        // time observer ÏÉùÏÑ± ÌõÑ tokenÏóê Ï†ÄÏû•
        switch isFirstCard{
        case true:
            firstCardtimeObserverToken = card.queuePlayer.addPeriodicTimeObserver(
                forInterval:interval,
                queue: DispatchQueue.main,
                using: { [weak self] currentTime in
                    self?.updateVideoSlider(card: card, time: currentTime)
                    // TODO: ÎÇ®ÏùÄ ÏãúÍ∞Ñ ÌëúÏãú
                    // self?.updateTimeRemaining(currentTime)
                })
            NSLog("üíô add first observer: \(String(describing: firstCardtimeObserverToken))")
        case false:
            timeObserverToken = card.queuePlayer.addPeriodicTimeObserver(
                forInterval:interval,
                queue: DispatchQueue.main,
                using: { [weak self] currentTime in
                    self?.updateVideoSlider(card: card, time: currentTime)
                    // TODO: ÎÇ®ÏùÄ ÏãúÍ∞Ñ ÌëúÏãú
                    // self?.updateTimeRemaining(currentTime)
                })
            NSLog("üíö add other observer: \(String(describing: timeObserverToken))")
        }
    }
    
    func removePeriodicTimeObserver(card: SwipeableCardVideoView, isFirstCard: Bool){
        
        switch isFirstCard {
        case true:
            if let timeObserverToken = firstCardtimeObserverToken {
                card.queuePlayer.removeTimeObserver(timeObserverToken)
                self.firstCardtimeObserverToken = nil
                NSLog("üíú romove first observer")
            }
        case false:
            if let timeObserverToken = timeObserverToken {
                card.queuePlayer.removeTimeObserver(timeObserverToken)
                self.timeObserverToken = nil
                NSLog("üíõ romove observer")
            }
        }
    }
}

// Level
extension LevelAndPFSettingViewController: LevelPickerViewDelegate {
    func setSeparatorColor() {
        self.separator.backgroundColor = .orrBlack
    }
    
    func didLevelChanged(selectedLevel: Int) {
        let levelButtonTiltle = selectedLevel == -1 ? "ÏÑ†ÌÉùÏïàÌï®" : "V\(selectedLevel)"
        levelButton.setTitle(levelButtonTiltle, for: .normal)
        currentSelectedLevel = selectedLevel
    }
}

// Gesture
private extension LevelAndPFSettingViewController {
    
    // Î™©ÏóÖÏö© Ïπ¥ÎìúÎ•º ÎßåÎì§Ïñ¥Ï§çÎãàÎã§.
    func createSwipeableCard(_ completion: @escaping () -> Void) {
        
        var identifiers: [String] = []
        for videoInfo in videoInfoArray {
            identifiers.append(videoInfo.videoLocalIdentifier)
        }
        
        // ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÌïòÎäî PHFetchOptions ÏÑ§Ï†ï
        let option = PHFetchOptions()
        option.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: true)]
        
        // identifiersÎ•º Í∏∞Î∞òÏúºÎ°ú Î∂àÎü¨Ïò® PHAssetÏùÑ PHFetchResult<PHAsset> ÌÉÄÏûÖÏúºÎ°ú Î≥ÄÌôò
        let assets = PHAsset.fetchAssets(withLocalIdentifiers: identifiers, options: option)
        // PHFetchResult<PHAsset>Ïùò Asset Í∞úÏàòÎßåÌÅº Î∞∞Ïó¥ Í≥µÍ∞Ñ Ìï†Îãπ
        cards = Array(repeating: nil, count: assets.count)
        // ÏÑ†ÌÉùÎêú Ïπ¥ÎìúÏùò Í∞úÏàò
        selectedCard = cards.count
        // Asset Ïπ¥Ïö¥ÌåÖÏùÑ ÏúÑÌïú ÎîîÏä§Ìå®Ïπò Í∑∏Î£π
        let countingGroup = DispatchGroup()
        
        CustomIndicator.startLoading()
        
        for index in 0..<assets.count {
            
            // Asset Ïπ¥Ïö¥ÌåÖ +1
            countingGroup.enter()
            
            // ÎØ∏ÎîîÏñ¥Í∞Ä Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏ÌïòÎäî ÏΩîÎìú
            guard (assets[index].mediaType == PHAssetMediaType.video)
            else {
                print("ÎπÑÎîîÏò§ ÎØ∏ÎîîÏñ¥Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
                return
            }
            
            // ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú AssetÏùÑ Î∞õÏïÑÏò¨ ÏùºÏù¥ ÏÉùÍ≤ºÏùÑ Îïå ÎÇòÎäî Ïò§Î•ò Ìï¥Í≤∞ÏùÑ ÏúÑÌïú PHVideoRequestOptions ÏÑ§Ï†ï
            let option = PHVideoRequestOptions()
            option.isNetworkAccessAllowed = true
            
            PHImageManager().requestAVAsset(forVideo: assets[index], options: option) { (assets, audioMix, info) in
                
                let asset = assets as? AVURLAsset
                
                guard let url = asset?.url else {
                    // ÏòÅÏÉÅÏù¥ Î∂àÎü¨ÏôÄÏßÄÏßÄ ÏïäÏùÑ Ïãú Í≤ΩÍ≥†Ï∞ΩÍ≥º Ìï®Íªò Îí§Î°ú ÎèåÏïÑÍ∞ÄÎäî Î°úÏßÅ
                    let alret = UIAlertController(title: "ÏòÅÏÉÅÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.", message: "ÏòÅÏÉÅÏùÑ Î∂àÎü¨Ïò§Îäî Îç∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌïòÏòÄÏäµÎãàÎã§.\n\nÏòÅÏÉÅÏùò Ìè¨Îß∑Ïù¥ ÏùºÎ∞òÏ†ÅÏù¥ÏßÄ ÏïäÏùÄ ÏòÅÏÉÅÏùº Ïàò ÏûàÏúºÎãà ÌôïÏù∏ ÌõÑ Îã§Ïãú ÏóÖÎ°úÎìú Ìï¥ Ï£ºÏÑ∏Ïöî", preferredStyle: .alert)
                    
                    let confirm = UIAlertAction(title: "ÌôïÏù∏", style: .default) { _ in
                        self.navigationController?.popViewController(animated: true)
                    }
                    
                    alret.addAction(confirm)
                    
                    self.present(alret, animated: true) {
                        CustomIndicator.stopLoading()
                    }
                    return
                }
                
                // Main ThreadÏóêÏÑú ViewÎ•º ÎîîÏä§Ìå®Ïπò Í∑∏Î£π
                DispatchQueue.main.async(group: countingGroup) { [self] in
                    
                    let swipeCard = SwipeableCardVideoView(asset: AVAsset(url: url))
                    
                    swipeCard.embedVideo()
                    
                    cards[index] = swipeCard
                    
                    // Asset Ïπ¥Ïö¥ÌåÖ -1
                    countingGroup.leave()
                    
                    // Î∂ÑÎ•òÎêú Ïπ¥Îìú Î≤àÌò∏ ÎÑòÎ≤ÑÎßÅ
                    classifiedCard = index + 1
                    // 'Î∂ÑÎ•òÎêú Ïπ¥Îìú / ÏÑ†ÌÉùÎêú Ïπ¥Îìú' ÌòïÏãùÏùò Î¨∏ÏûêÏó¥ Í∞íÏùÑ ÎÑòÍ≤®Ï£ºÎäî Î©îÏÑúÎìú
                    swipeCard.getCardLabelText(labelText: "\(classifiedCard)/\(selectedCard)")
                }
                // Asset Ïπ¥Ïö¥ÌåÖÏù¥ 0Ïù¥ ÎêòÏóàÏùÑ Îïå completionHandlerÎ°ú Î∞òÌôò
                countingGroup.notify(queue: DispatchQueue.main) {
                    if self.firstCardtimeObserverToken == nil {
                        let firstCard = self.cards[0] as? SwipeableCardVideoView
                        guard let card = firstCard else { return }
                        // Ï≤´Î≤àÏß∏ Observer
                        self.addPeriodicTimeObserver(card: card, isFirstCard: true)
                        firstCard?.queuePlayer.play()
                    }
                    completion()
                }
            }
        }
    }
    
    // swipeCardÍ∞Ä SuperViewÏóêÏÑú Ï†úÍ±∞Îê©ÎãàÎã§.
    @objc func removeCard(card: UIView) {
        
        card.removeFromSuperview()
        // Ïä§ÏôÄÏù¥ÌîÑÍ∞Ä ÏôÑÎ£åÎêòÍ≥† removeCardÍ∞Ä Ìò∏Ï∂úÎê† Îïå Î≤ÑÌäº ÌôúÏÑ±Ìôî
        successButton.isEnabled = true
        failButton.isEnabled = true
        counter += 1

    }
    
    // Gesture
    @objc func handlerCard(_ gesture: UIPanGestureRecognizer) {
        if let card = gesture.view as? SwipeableCardVideoView {
            let point = gesture.translation(in: view)
            
            card.center = CGPoint(x: view.center.x + point.x, y: view.center.y + point.y)
            
            let horizonalRotationAngle = point.x / view.bounds.width * 0.4
            
            if point.x > 0 {
                card.successImageView.alpha = horizonalRotationAngle * 5
                card.failImageView.alpha = 0
                card.setVideoBackgroundViewBorderColor(color: .pass, alpha: horizonalRotationAngle * 5)
            } else {
                card.successImageView.alpha = 0
                card.failImageView.alpha = -horizonalRotationAngle * 5
                card.setVideoBackgroundViewBorderColor(color: .fail, alpha: -horizonalRotationAngle * 5)
            }
            
            card.transform = CGAffineTransform(rotationAngle: horizonalRotationAngle)
            
            if gesture.state == .ended {
                // Ïπ¥ÎìúÏùò xÏ∂ïÏùÑ ÌÜµÌïú ÏÑ±Ìå® Í≤∞Ï†ï Ïä§ÏôÄÏù¥ÌîÑ Ï†ïÎèÑ
                
                var cardPositionX = card.center.x
                
                switch cardPositionX {
                case self.view.bounds.width / 3 * 2..<self.view.bounds.width:
                    animateCard(rotationAngle: horizonalRotationAngle, videoResultType: .success)
                    return
                case 0..<self.view.bounds.width / 3:
                    animateCard(rotationAngle: horizonalRotationAngle, videoResultType: .fail)
                    return
                default:
                    card.center = self.emptyVideoView.center
                    card.transform = .identity
                    card.successImageView.alpha = 0
                    card.failImageView.alpha = 0
                    card.setVideoBackgroundViewBorderColor(color: .clear, alpha: 1)
                    return
                }
            }
        }
    }
    
    @objc func pickLevel() {
        let nextViewController = LevelPickerView()
        nextViewController.pickerSelectValue = currentSelectedLevel + 1
        self.navigationController?.present(nextViewController, animated: true)
        separator.backgroundColor = .orrUPBlue
        nextViewController.delegate = self
    }
    
    // Ïã§Ìå® Î≤ÑÌäºÏùÑ ÎàåÎ†ÄÏùÑ Îïå Î°úÏßÅ
    @objc func didFailButton() {
        animateCard(rotationAngle: -0.4, videoResultType: .fail)
        failButton.isActivated.toggle()
    }
    
    // ÏÇ≠Ï†ú Î≤ÑÌäºÏùÑ ÎàåÎ†ÄÏùÑ Îïå Î°úÏßÅ
    @objc func didDeleteButton() {
        print("tapped")
        animateCard(rotationAngle: 0, videoResultType: .delete)
    }
    
    // ÏÑ±Í≥µ Î≤ÑÌäºÏùÑ ÎàåÎ†ÄÏùÑ Îïå Î°úÏßÅ
    @objc func didSuccessButton() {
        animateCard(rotationAngle: 0.4, videoResultType: .success)
        successButton.isActivated.toggle()
    }
    
    // Îã§Ïùå Î∑∞Î°ú ÎÑòÏñ¥Í∞ÄÎäî Î°úÏßÅ
    @objc func tapSaveButton() {
        DataManager.shared.createMultipleData(infoList: videoInfoArray.filter{ $0.isDeleted == false })
        self.navigationController?.popToRootViewController(animated: true)
    }
    
    // swipeCardÏùò Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥ºÎ•º Îã¥ÎãπÌï©ÎãàÎã§.
    func animateCard(rotationAngle: CGFloat, videoResultType: VideoResultType) {
        
//        if counter == 0 {
//            guard let card = cards[counter] else { return }
//            removePeriodicTimeObserver(card: card, isFirstCard: counter == 0)
//        }
        
        if counter == 0 {
            guard let card = cards[counter] else { return }
            removePeriodicTimeObserver(card:  card, isFirstCard: counter == 0)
        }
        

        let cardViews = view.subviews.filter({ ($0 as? SwipeableCardVideoView) != nil })
        
        for view in cardViews {
            
            if view == cards[counter] {
                let center: CGPoint
                let isSuccess: Bool
                let isDeleted: Bool
                let card = view as! SwipeableCardVideoView
                
                // ÎßàÏßÄÎßâ Ïπ¥ÎìúÍ∞Ä ÏïÑÎãê Îïå Îã§Ïùå Ïπ¥ÎìúÎ•º Ïû¨ÏÉù
                if counter != cards.count-1 {
                    
                    // Îã§ÏùåÏóê ÎÇòÏò¨ Ïπ¥Îìú
                    guard let nextCard = cards[counter + 1] as? SwipeableCardVideoView else { return }
                    // SliderÏóê ÏãúÍ∞Ñ Ï†ïÎ≥¥Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ∏∞ ÏúÑÌïú Observer Ï∂îÍ∞Ä
                    addPeriodicTimeObserver(card: nextCard, isFirstCard: false)
                    // Ïù¥Ï†Ñ Ïπ¥ÎìúÍ∞Ä Ïä§ÏôÄÏù¥ÌîÑÍ∞Ä ÎêòÏóàÏùÑ Îïå Îã§ÏùåÏóê ÎÇòÏò¨ Ïπ¥ÎìúÍ∞Ä Ïû¨ÏÉù
                    nextCard.queuePlayer.play()
                }
                
                switch videoResultType {
                case .fail:
                    center = CGPoint(x: card.center.x - view.bounds.width, y: card.center.y + 30)
                    isSuccess = false
                    isDeleted = false
                case .success:
                    center = CGPoint(x: card.center.x + view.bounds.width, y: card.center.y + 30)
                    isSuccess = true
                    isDeleted = false
                case .delete:
                    center = CGPoint(x: card.center.x, y: card.center.y - view.bounds.height)
                    isSuccess = false
                    isDeleted = true
                }
                
                if isDeleted {
                    videoInfoArray[counter].isDeleted = true
                } else {
                    // ÏÑ±Í≥µÏù¥ÎÇò Ïã§Ìå®Î°ú Î∂ÑÎ•òÎêòÎ©¥ ÏÑ±Ìå® Ïó¨Î∂ÄÏôÄ Î†àÎ≤® Ï†ïÎ≥¥ Ï†ÄÏû•
                    videoInfoArray[counter].isSucceeded = isSuccess
                    videoInfoArray[counter].problemLevel = currentSelectedLevel ?? 0
                }
                    
                    UIView.animate(withDuration: 0.3, animations: {
                        card.center = center
                        card.transform = CGAffineTransform(rotationAngle: rotationAngle)
                        if !isDeleted{
                            card.successImageView.alpha = isSuccess == true ? 1 : 0
                            card.failImageView.alpha = isSuccess == false ? 1 : 0
                            
                            if isSuccess{
                                card.setVideoBackgroundViewBorderColor(color: .pass, alpha: 1)
                            } else {
                                card.setVideoBackgroundViewBorderColor(color: .fail, alpha: 1)
                            }
                            
                        } else {
                            // Ïπ¥Îìú ÏÇ≠Ï†úÏãú Ïï†ÎãàÎ©îÏù¥ÏÖò
                            // TODO: ÏÇ≠Ï†ú ÎùºÎ≤® alpha
                            // TODO: ÏÇ≠Ï†ú Î≥¥Îçî alpha
                            card.setVideoBackgroundViewBorderColor(color: .delete, alpha: 1)
                            
                        }
                        // Ïπ¥Îìú Ïä§ÏôÄÏù¥ÌîÑ Ïï†ÎãàÎß§Ïù¥ÏÖòÏù¥ ÏßÑÌñâ Ï§ëÏùº Îïå Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî
                        self.successButton.isEnabled = false
                        self.failButton.isEnabled = false
                        
                    }) { [self] _ in
                        // ÎßàÏßÄÎßâ Ïπ¥ÎìúÍ∞Ä ÏïÑÎãàÎ©¥
//                        if firstCardtimeObserverToken == nil {
//                            removePeriodicTimeObserver(card:  card, isFirstCard: false)
//                        }
                        if counter != cards.count-1 {
                            removeCard(card: card)
                        } else {
                            didVideoClassificationComplete()
                            removeCard(card: card)
                        }
                        print("\n‚ú® counter: \(counter)\n", "üëè videoInfoArray: \(videoInfoArray)\n" )
                    }
                
            }
        }
    }
    
    @objc func backButtonClicked() {
        self.navigationController?.popViewController(animated: true)
    }
    
    // Î™®Îì† Ïπ¥ÎìúÎ•º Ïä§ÏôÄÏù¥Ìïë ÌñàÏùÑ Îïå Ìò∏Ï∂úÎêòÎäî Î©îÏÑúÎìú
    func didVideoClassificationComplete() {
        // ÌïúÎ≤à Îçî Ï†úÍ±∞Ìï¥Ï£ºÎäî Î°úÏßÅ
        cards.removeAll()

        levelButton.isEnabled = false
        
        saveButton.isHidden = false
        successButton.isHidden = true
        failButton.isHidden = true
        deleteButton.isHidden = true
        videoSlider.isHidden = true
        
        titleLabel.text = "Î∂ÑÎ•ò ÏôÑÎ£å! Ï†ÄÏû•ÌïòÍ∏∞Î•º ÎàåÎü¨Ï£ºÏÑ∏Ïöî."
        buttonStackView.isUserInteractionEnabled = false
        
        titleLabel.textColor = .orrGray500
        levelButton.tintColor = .orrGray500
    }
}

private extension LevelAndPFSettingViewController {
    
    func setUpLayout() {
        
        [levelButton, levelButtonImage].forEach {
            self.buttonStackView.addArrangedSubview($0)
        }
        
        [levelLabel, buttonStackView].forEach {
            self.levelStackView.addArrangedSubview($0)
        }
        
        let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(pickLevel))
        buttonStackView.isUserInteractionEnabled = true
        buttonStackView.addGestureRecognizer(tapGestureRecognizer)
        
        view.addSubview(headerView)
        headerView.snp.makeConstraints {
            $0.leading.trailing.equalToSuperview()
            $0.top.equalTo(view.safeAreaLayoutGuide)
        }
        
        headerView.addSubview(titleLabel)
        titleLabel.snp.makeConstraints {
            $0.centerX.equalTo(headerView.snp.centerX)
            $0.top.equalTo(headerView.snp.top)
        }
        
        buttonStackView.snp.makeConstraints {
            $0.width.equalTo(90.0)
        }
        
        headerView.addSubview(levelStackView)
        levelStackView.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.top.equalTo(titleLabel.snp.bottom).offset(OrrPd.pd16.rawValue)
            $0.centerX.equalToSuperview()
        }
        
        levelButtonImage.snp.makeConstraints {
            $0.height.equalTo(20.0)
            $0.width.equalTo(20.0)
        }
        
        headerView.addSubview(separator)
        separator.snp.makeConstraints {
            $0.centerX.equalTo(buttonStackView.snp.centerX)
            $0.top.equalTo(buttonStackView.snp.bottom).offset(8.0)
            $0.bottom.equalTo(headerView.snp.bottom)
            $0.height.equalTo(2.0)
            $0.width.equalTo(90.0)
        }
        
        // TODO: SliderÍ∞Ä ÎÑàÎ¨¥ Îπ®Î¶¨ Í∑∏Î†§ÏßÄÎäî Ïù¥Ïäà
        view.addSubview(videoSlider)
        videoSlider.snp.makeConstraints {
            $0.bottom.equalTo(view.safeAreaLayoutGuide.snp.bottom).offset(OrrPd.pd16.rawValue)
            // TODO: Slider Ï¥àÍ∏∞, ÌõÑÍ∏∞Ïóê Í∏âÌïòÍ≤å Í∞íÏù¥ Î≥ÄÎèôÎêòÏñ¥ offsetÏúºÎ°ú Ìï¥Îãπ ÏòÅÏó≠ Ïà®ÍπÄ. Ïä¨ÎùºÏù¥Îçî ÎîîÌÖåÏùº ÏûëÏóÖ Î≥¥ÏôÑ ÏòàÏ†ï.
            $0.leading.equalTo(view.safeAreaLayoutGuide).offset(-OrrPd.pd24.rawValue)
            $0.trailing.equalTo(view.safeAreaLayoutGuide).offset(OrrPd.pd24.rawValue)
            $0.height.equalTo(56)
        }
        
        view.addSubview(failButton)
        failButton.snp.makeConstraints {
            $0.bottom.equalTo(videoSlider.snp.top).offset(-OrrPd.pd16.rawValue)
            $0.leading.equalToSuperview().inset(48.0)
            $0.height.equalTo(74.0)
            $0.width.equalTo(74.0)
        }
        
        view.addSubview(deleteButton)
        deleteButton.snp.makeConstraints {
            $0.bottom.equalTo(videoSlider.snp.top).offset(-OrrPd.pd16.rawValue)
            $0.centerX.equalToSuperview()
            $0.height.equalTo(74.0)
            $0.width.equalTo(74.0)
        }
        
        view.addSubview(successButton)
        successButton.snp.makeConstraints {
            $0.bottom.equalTo(videoSlider.snp.top).offset(-OrrPd.pd16.rawValue)
            $0.trailing.equalToSuperview().inset(48.0)
            $0.height.equalTo(74.0)
            $0.width.equalTo(74.0)
        }
        
        view.addSubview(emptyVideoView)
        emptyVideoView.snp.makeConstraints {
            $0.centerX.equalToSuperview()
            $0.top.equalTo(separator.snp.bottom).offset(OrrPd.pd20.rawValue)
            $0.bottom.equalTo(successButton.snp.top).offset(-OrrPd.pd20.rawValue)
            $0.width.equalTo(emptyVideoView.snp.height).multipliedBy(0.5625)
        }
        
        // TODO: Ïπ¥Îìú Ïä§ÌÉù Ïä§ÏºàÎ†àÌÜ§ Í∞í Ï°∞Ï†ï ÌïÑÏöî
//        view.addSubview(backgroundCardStackView)
//        backgroundCardStackView.snp.makeConstraints {
//            $0.center.equalTo(view.center)
//            $0.height.equalTo(view.snp.height)
//            $0.width.equalTo(view.snp.width)
//            $0.top.equalTo(emptyVideoView.snp.top)
//            $0.bottom.equalTo(emptyVideoView.snp.bottom)
//            backgroundCardStackView.setUpLayout()
//        }
        
        emptyVideoView.addSubview(emptyVideoInformation)
        emptyVideoInformation.snp.makeConstraints {
            $0.center.equalTo(emptyVideoView.snp.center)
        }
        
        view.addSubview(saveButton)
        saveButton.snp.makeConstraints {
            $0.bottom.equalTo(view.safeAreaLayoutGuide).offset(-OrrPd.pd16.rawValue)
            $0.leading.equalTo(view).offset(OrrPd.pd16.rawValue)
            $0.trailing.equalTo(view).offset(-OrrPd.pd16.rawValue)
            $0.height.equalTo(56)
        }
    }
}
